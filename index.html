<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Our Sky</title>
  <style>
    :root{
      --bg1:#020408;
      --bg2:#050810;
      --ink:#e9eefc;
      --muted:rgba(233,238,252,.72);
      --thin:rgba(233,238,252,.35);
      --accent:rgba(155,200,255,.9);
    }
    html,body{
      height:100%;
      margin:0;
      background: var(--bg1);
      overflow:hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: var(--ink);
    }
    #wrap{
      position:relative;
      width:100%;
      height:100%;
    }
    canvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
    }
    #bgCanvas{
      z-index: 0;
    }
    #sky{
      z-index: 1;
    }

    /* Poster overlay */
    .poster{
      position:absolute;
      inset:0;
      pointer-events:none;
      display:grid;
      place-items:center;
      padding: clamp(18px, 3vw, 40px);
      z-index: 2;
    }
    .frame{
      width:min(820px, 92vw);
      aspect-ratio: 3 / 4;
      border: 1px solid rgba(233,238,252,.22);
      border-radius: 18px;
      box-shadow: 0 24px 80px rgba(0,0,0,.55), 0 0 120px rgba(60,100,180,0.08);
      position:relative;
      background: linear-gradient(180deg, rgba(255,255,255,.015), rgba(255,255,255,.00));
      overflow:hidden;
    }
    .frame::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius: 18px;
      box-shadow: 0 0 0 rgba(140, 190, 255, 0);
      transition: box-shadow .4s ease;
      pointer-events:none;
    }
    .frame:hover::after{
      box-shadow: 0 0 0 1px rgba(140, 190, 255, .25), 0 0 28px rgba(120, 180, 255, .18);
    }
    .frame::before{
      content:"";
      position:absolute;
      inset:14px;
      border: 1px solid rgba(233,238,252,.10);
      border-radius: 14px;
      pointer-events:none;
    }
    .label{
      position:absolute;
      left:0; right:0;
      bottom:0;
      padding: 22px 24px 24px;
      background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,.30) 55%, rgba(0,0,0,.55) 100%);
    }
    .desc-card{
      position:absolute;
      left:18px;
      top:44px;
      max-width: 220px;
      padding:10px 12px;
      border:1px solid rgba(233,238,252,.12);
      border-radius:10px;
      background: rgba(5,8,14,.55);
      color: rgba(233,238,252,.7);
      font-size:11px;
      line-height:1.5;
      letter-spacing:.08em;
      text-transform:uppercase;
      backdrop-filter: blur(6px);
    }
    .ruler{
      position:absolute;
      top:90px;
      right:18px;
      width:1px;
      height:120px;
      background: rgba(233,238,252,.18);
    }
    .ruler::before,
    .ruler::after{
      content:"";
      position:absolute;
      left:-4px;
      width:9px;
      height:1px;
      background: rgba(233,238,252,.2);
    }
    .ruler::before{ top:0; }
    .ruler::after{ bottom:0; }
    .ruler .tag{
      position:absolute;
      top:50%;
      right:8px;
      transform: translateY(-50%);
      font-size:9px;
      letter-spacing:.18em;
      text-transform:uppercase;
      color: rgba(233,238,252,.45);
      white-space:nowrap;
    }
    .secret{
      position:absolute;
      left:50%;
      top:50%;
      transform: translate(-50%, -50%);
      font-size:12px;
      letter-spacing:.28em;
      text-transform:uppercase;
      color: rgba(233,238,252,.12);
      opacity:0;
      transition: opacity .6s ease;
      pointer-events:none;
    }
    .frame:hover .secret{
      opacity:1;
    }
    .pin{
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .pin::before{
      content:"";
      width:6px;
      height:6px;
      border-radius:50%;
      border:1px solid rgba(233,238,252,.6);
      box-shadow: 0 0 6px rgba(233,238,252,.35);
      transform: translateY(1px);
    }
    .title{
      letter-spacing:.28em;
      font-size: 12px;
      text-transform: uppercase;
      color: var(--muted);
      margin:0 0 8px;
    }
    .names{
      margin:0;
      font-size: clamp(20px, 2.8vw, 30px);
      letter-spacing:.06em;
      font-weight:650;
    }
    .sub{
      margin:10px 0 0;
      font-size: 13px;
      letter-spacing:.18em;
      text-transform: uppercase;
      color: var(--thin);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .dot{
      width:3px;height:3px;border-radius:50%;
      background: rgba(233,238,252,.35);
      display:inline-block;
      transform: translateY(-1px);
    }

    .corner{
      position:absolute;
      top:16px;
      left:50%;
      transform: translateX(-50%);
      font-size:12px;
      letter-spacing:.28em;
      text-transform:uppercase;
      color: rgba(233,238,252,.7);
      font-weight: 700;
      user-select:none;
    }
    .grain{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index: 3;
      opacity: 0.18;
      mix-blend-mode: soft-light;
      background-image:
        radial-gradient(rgba(255,255,255,0.12) 0.6px, transparent 0.6px),
        radial-gradient(rgba(0,0,0,0.18) 0.7px, transparent 0.7px);
      background-size: 3px 3px, 4px 4px;
      background-position: 0 0, 1px 1px;
    }
    .legend{
      position:absolute;
      right:18px;
      bottom:150px;
      display:flex;
      gap:10px;
      align-items:center;
      font-size:10px;
      letter-spacing:.18em;
      text-transform:uppercase;
      color: rgba(233,238,252,.55);
    }
    .legend .dot{
      width:6px;
      height:6px;
      border-radius:50%;
      background: rgba(233,238,252,.7);
      box-shadow: 0 0 6px rgba(233,238,252,.6);
    }
    .legend .mid{
      width:4px;
      height:4px;
      box-shadow: 0 0 4px rgba(233,238,252,.4);
      opacity:.75;
    }
    .legend .dim{
      width:3px;
      height:3px;
      box-shadow: 0 0 3px rgba(233,238,252,.25);
      opacity:.55;
    }
    .star-info{
      position:absolute;
      top:16px;
      right:16px;
      width:min(260px, 44%);
      background: rgba(3,5,9,.55);
      border: 1px solid rgba(233,238,252,.12);
      border-radius: 12px;
      padding: 12px 14px;
      backdrop-filter: blur(6px);
      font-size:12px;
      letter-spacing:.08em;
      color: rgba(233,238,252,.8);
      text-transform: uppercase;
    }
    .star-info .name{
      display:block;
      font-size:13px;
      letter-spacing:.18em;
      color: rgba(233,238,252,.95);
      margin-bottom:6px;
    }
    .star-info .value{
      display:block;
      font-size:12px;
      letter-spacing:.05em;
      text-transform:none;
      color: rgba(233,238,252,.7);
      margin-top:4px;
    }

    @media (prefers-reduced-motion: reduce){
      .corner{ display:none; }
    }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="bgCanvas"></canvas>
  <canvas id="sky"></canvas>

  <div class="poster">
    <div class="frame" aria-hidden="true">
      <div class="corner">our map</div>
      <div class="desc-card">
        A star map of the night Maria &amp; Giorgos met in Athens.
      </div>
      <div class="star-info" id="starInfo">
        <span class="name">Hover a bright star</span>
      </div>
      <div class="legend" aria-hidden="true">
        <span class="dot"></span>
        <span>bright</span>
        <span class="dot mid"></span>
        <span>medium</span>
        <span class="dot dim"></span>
        <span>faint</span>
      </div>
      <div class="label">
        <p class="title">The night we became "us"</p>
        <p class="names">Maria &amp; Giorgos <span aria-hidden="true">❤</span></p>
        <p class="sub">
          <span id="dateText">January 8, 2026</span>
          <span class="dot"></span>
          <span class="pin" id="placeText">Athens</span>
          <span class="dot"></span>
          <span id="coordsText">38.0407°N 23.6872°E</span>
        </p>
      </div>
      <div class="ruler" aria-hidden="true"><span class="tag">lat / lon</span></div>
      <div class="secret" aria-hidden="true">where it began</div>
    </div>
  </div>
  <div class="grain" aria-hidden="true"></div>
</div>

<script>
(() => {
  // ========= Configuration =========
  const CONFIG = {
    year: 2026,
    month: 1,      // January
    day: 8,
    hour: 21,      // 9 PM local time - romantic evening
    placeName: "Athens",
    lat: 38.04066366615578,
    lon: 23.687203255515126,
    timezone: 2,   // UTC+2 for Athens (EET in winter)

    // Visual style
    showConstellationLines: true,
    nebulaIntensity: 0.32,
  };

  // ========= Bright Star Catalog =========
  // Real star data: [name, RA (hours), Dec (degrees), magnitude, color index]
  // Using the 100 brightest stars visible from Northern Hemisphere
  const STARS = [
    ["Sirius", 6.752, -16.716, -1.46, -0.01],
    ["Canopus", 6.399, -52.696, -0.72, 0.15],
    ["Arcturus", 14.261, 19.182, -0.04, 1.23],
    ["Vega", 18.616, 38.784, 0.03, 0.00],
    ["Capella", 5.278, 45.998, 0.08, 0.80],
    ["Rigel", 5.242, -8.202, 0.12, -0.03],
    ["Procyon", 7.655, 5.225, 0.34, 0.42],
    ["Betelgeuse", 5.919, 7.407, 0.42, 1.85],
    ["Altair", 19.846, 8.868, 0.77, 0.22],
    ["Aldebaran", 4.599, 16.509, 0.85, 1.54],
    ["Antares", 16.490, -26.432, 0.96, 1.83],
    ["Spica", 13.420, -11.161, 0.97, -0.23],
    ["Pollux", 7.755, 28.026, 1.14, 1.00],
    ["Fomalhaut", 22.961, -29.622, 1.16, 0.09],
    ["Deneb", 20.690, 45.280, 1.25, 0.09],
    ["Regulus", 10.139, 11.967, 1.35, -0.11],
    ["Castor", 7.577, 31.888, 1.58, 0.03],
    ["Bellatrix", 5.419, 6.350, 1.64, -0.22],
    ["Elnath", 5.438, 28.608, 1.65, -0.13],
    ["Alnilam", 5.603, -1.202, 1.70, -0.18],
    ["Alnitak", 5.679, -1.943, 1.77, -0.21],
    ["Alioth", 12.900, 55.960, 1.77, -0.02],
    ["Dubhe", 11.062, 61.751, 1.79, 1.07],
    ["Mirfak", 3.405, 49.861, 1.80, 0.48],
    ["Kaus Australis", 18.403, -34.385, 1.80, -0.03],
    ["Alkaid", 13.792, 49.313, 1.86, -0.19],
    ["Sargas", 17.622, -42.998, 1.87, 0.40],
    ["Menkalinan", 5.992, 44.948, 1.90, 0.08],
    ["Alhena", 6.629, 16.399, 1.93, 0.00],
    ["Peacock", 20.428, -56.735, 1.94, -0.20],
    ["Mirzam", 6.378, -17.956, 1.98, -0.24],
    ["Alphard", 9.460, -8.659, 1.98, 1.44],
    ["Hamal", 2.120, 23.463, 2.00, 1.15],
    ["Polaris", 2.530, 89.264, 2.02, 0.60],
    ["Diphda", 0.727, -17.987, 2.02, 1.02],
    ["Mizar", 13.399, 54.925, 2.04, 0.02],
    ["Nunki", 18.921, -26.297, 2.05, -0.13],
    ["Miaplacidus", 9.220, -69.717, 1.68, 0.00],
    ["Alpheratz", 0.140, 29.091, 2.06, -0.11],
    ["Algenib", 0.220, 15.185, 2.83, -0.22],
    ["Mirach", 1.163, 35.620, 2.05, 1.58],
    ["Rasalhague", 17.582, 12.560, 2.07, 0.15],
    ["Algol", 3.136, 40.957, 2.12, -0.05],
    ["Denebola", 11.818, 14.572, 2.13, 0.09],
    ["Naos", 8.059, -40.003, 2.25, -0.27],
    ["Gamma Velorum", 8.159, -47.337, 1.78, -0.22],
    ["Wezen", 7.140, -26.393, 1.84, 0.67],
    ["Sadr", 20.370, 40.257, 2.20, 0.67],
    ["Saiph", 5.796, -9.670, 2.06, -0.18],
    ["Schedar", 0.675, 56.537, 2.23, 1.17],
    ["Eltanin", 17.944, 51.489, 2.23, 1.52],
    ["Mintaka", 5.533, -0.299, 2.23, -0.21],
    ["Caph", 0.153, 59.150, 2.27, 0.34],
    ["Epsilon Centauri", 13.665, -53.467, 2.30, -0.22],
    ["Dschubba", 16.006, -22.622, 2.32, -0.12],
    ["Larawag", 17.708, -37.043, 2.29, 1.46],
    ["Eta Centauri", 14.592, -42.158, 2.31, -0.19],
    ["Merak", 11.031, 56.382, 2.37, 0.03],
    ["Izar", 14.750, 27.074, 2.37, 0.97],
    ["Enif", 21.736, 9.875, 2.39, 1.52],
    ["Ankaa", 0.438, -42.306, 2.39, 1.09],
    ["Phecda", 11.897, 53.695, 2.44, 0.04],
    ["Sabik", 17.173, -15.725, 2.43, 0.06],
    ["Scheat", 23.063, 28.083, 2.42, 1.67],
    ["Aludra", 7.402, -29.303, 2.45, -0.08],
    ["Markab", 23.079, 15.205, 2.49, -0.04],
    ["Alderamin", 21.310, 62.585, 2.51, 0.22],
    ["Markeb", 9.368, -55.011, 2.50, -0.17],
    ["Zubeneschamali", 15.283, -9.383, 2.61, -0.11],
    ["Acrab", 16.091, -19.806, 2.62, -0.07],
    ["Rasalgethi", 17.244, 14.390, 2.78, 1.44],
    ["Kochab", 14.845, 74.156, 2.08, 1.47],
    ["Algedi", 20.294, -12.508, 2.87, 0.84],
    ["Alphecca", 15.578, 26.715, 2.23, 0.02],
    ["Unukalhai", 15.737, 6.426, 2.65, 1.24],
    ["Lesath", 17.530, -37.296, 2.69, -0.22],
    ["Zubenelgenubi", 14.848, -16.042, 2.75, 0.14],
    ["Kornephoros", 16.503, 21.490, 2.77, 0.94],
    ["Thuban", 14.073, 64.376, 3.65, -0.05],
    ["Phad", 11.897, 53.695, 2.44, 0.04],
    ["Alshain", 19.922, 6.407, 3.71, 0.86],
    ["Tarazed", 19.771, 10.613, 2.72, 1.51],
    ["Gienah", 12.263, -17.542, 2.59, -0.12],
    ["Zosma", 11.235, 20.524, 2.56, 0.12],
    ["Minkar", 12.168, -22.620, 3.02, 1.43],
    ["Acamar", 2.971, -40.305, 2.91, 0.13],
    ["Cursa", 5.130, -5.086, 2.79, 0.13],
    ["Hassaleh", 4.950, 33.166, 2.69, 0.54],
    ["Menkib", 3.982, 35.791, 2.85, -0.18],
    ["Sheratan", 1.911, 20.808, 2.64, 0.13],
    ["Nashira", 21.668, -16.662, 3.68, 0.04],
    ["Albali", 20.795, -9.496, 3.77, 0.02],
    ["Skat", 22.911, -15.821, 3.27, -0.02],
    ["Atria", 16.811, -69.028, 1.92, 1.44],
    ["Alula Australis", 11.182, 31.529, 3.78, 0.59],
    ["Alula Borealis", 11.310, 33.094, 3.48, 1.40],
  ];

  // Constellation line connections [star1_index, star2_index]
  const CONSTELLATION_LINES = [
    // Orion
    [5, 7], [5, 17], [7, 17], [5, 48], [7, 19], [19, 20], [19, 51],
    // Ursa Major (Big Dipper)
    [21, 22], [22, 57], [57, 61], [61, 35], [35, 25], [25, 21],
    // Cassiopeia
    [38, 52], [52, 49], [49, 42],
    // Cygnus
    [14, 47], [47, 8],
    // Leo
    [15, 43], [43, 83],
    // Gemini
    [6, 12], [12, 16],
    // Taurus
    [9, 18], [18, 87],
    // Scorpius
    [10, 54], [54, 75],
  ];

  // Update overlay text
  document.getElementById("dateText").textContent = `January ${CONFIG.day}, ${CONFIG.year}`;
  document.getElementById("placeText").textContent = CONFIG.placeName;
  document.getElementById("coordsText").textContent =
    `${Math.abs(CONFIG.lat).toFixed(4)}°${CONFIG.lat>=0?"N":"S"} ${Math.abs(CONFIG.lon).toFixed(4)}°${CONFIG.lon>=0?"E":"W"}`;

  // ========= Astronomical calculations =========
  function julianDate(year, month, day, hour) {
    if (month <= 2) {
      year -= 1;
      month += 12;
    }
    const A = Math.floor(year / 100);
    const B = 2 - A + Math.floor(A / 4);
    const JD = Math.floor(365.25 * (year + 4716)) + Math.floor(30.6001 * (month + 1)) + day + (hour / 24) + B - 1524.5;
    return JD;
  }

  function localSiderealTime(jd, longitude) {
    const T = (jd - 2451545.0) / 36525;
    let GST = 280.46061837 + 360.98564736629 * (jd - 2451545.0) + T * T * (0.000387933 - T / 38710000);
    GST = GST % 360;
    if (GST < 0) GST += 360;
    let LST = GST + longitude;
    LST = LST % 360;
    if (LST < 0) LST += 360;
    return LST;
  }

  function raDecToAltAz(ra, dec, lat, lst) {
    // Convert to radians
    const raRad = (ra * 15) * Math.PI / 180; // RA is in hours, convert to degrees then radians
    const decRad = dec * Math.PI / 180;
    const latRad = lat * Math.PI / 180;
    const lstRad = lst * Math.PI / 180;

    // Hour angle
    const ha = lstRad - raRad;

    // Altitude
    const sinAlt = Math.sin(decRad) * Math.sin(latRad) + Math.cos(decRad) * Math.cos(latRad) * Math.cos(ha);
    const alt = Math.asin(sinAlt);

    // Azimuth
    const cosAz = (Math.sin(decRad) - Math.sin(alt) * Math.sin(latRad)) / (Math.cos(alt) * Math.cos(latRad));
    const sinAz = -Math.sin(ha) * Math.cos(decRad) / Math.cos(alt);
    let az = Math.atan2(sinAz, cosAz);

    return {
      altitude: alt * 180 / Math.PI,
      azimuth: (az * 180 / Math.PI + 360) % 360
    };
  }

  // Calculate star positions for the given date/time/location
  const utcHour = CONFIG.hour - CONFIG.timezone;
  const jd = julianDate(CONFIG.year, CONFIG.month, CONFIG.day, utcHour);
  const lst = localSiderealTime(jd, CONFIG.lon);

  // ========= Canvas setup =========
  const canvas = document.getElementById("sky");
  const ctx = canvas.getContext("2d", { alpha: true });
  const staticCanvas = document.createElement("canvas");
  const staticCtx = staticCanvas.getContext("2d", { alpha: true });
  const bgCanvas = document.getElementById("bgCanvas");
  const bgCtx = bgCanvas.getContext("2d", { alpha: false });
  const wrap = document.getElementById("wrap");

  // Subtle parallax for background (driven by main loop)
  let parallaxX = 0;
  let parallaxY = 0;
  let targetX = 0;
  let targetY = 0;
  wrap.addEventListener("pointermove", (e) => {
    const rect = wrap.getBoundingClientRect();
    const mx = (e.clientX - rect.left) / rect.width - 0.5;
    const my = (e.clientY - rect.top) / rect.height - 0.5;
    targetX = mx * 12;
    targetY = my * 12;
  }, { passive: true });
  wrap.addEventListener("pointerleave", () => {
    targetX = 0;
    targetY = 0;
  }, { passive: true });

  let W = 0, H = 0, DPR = 1;
  function resize(){
    const dpr = window.devicePixelRatio || 1;
    const lowPower = (navigator.deviceMemory && navigator.deviceMemory <= 4) ||
      (navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4) ||
      (window.innerWidth * window.innerHeight > 1600000);
    const maxDpr = lowPower ? 1.2 : 1.5;
    DPR = Math.max(1, Math.min(maxDpr, dpr));
    W = Math.floor(window.innerWidth * DPR);
    H = Math.floor(window.innerHeight * DPR);
    canvas.width = W;
    canvas.height = H;
    staticCanvas.width = W;
    staticCanvas.height = H;
    bgCanvas.width = W;
    bgCanvas.height = H;
    drawBackground();
    applyPosterVignette();
  }
  window.addEventListener("resize", resize, { passive:true });
  resize();

  // ========= Background with nebula effects =========
  function drawBackground() {
    // Base dark gradient
    const baseGrad = bgCtx.createRadialGradient(W * 0.5, H * 0.4, 0, W * 0.5, H * 0.5, Math.max(W, H) * 0.8);
    baseGrad.addColorStop(0, '#0a0d18');
    baseGrad.addColorStop(0.3, '#060912');
    baseGrad.addColorStop(0.6, '#030508');
    baseGrad.addColorStop(1, '#010203');
    bgCtx.fillStyle = baseGrad;
    bgCtx.fillRect(0, 0, W, H);

    // Nebula clouds using multiple layered gradients
    const nebulaColors = [
      { x: 0.3, y: 0.25, r: 0.35, rgb: [30, 50, 100], alpha: 0.12 },
      { x: 0.7, y: 0.35, r: 0.3, rgb: [60, 30, 80], alpha: 0.08 },
      { x: 0.5, y: 0.5, r: 0.4, rgb: [20, 40, 80], alpha: 0.10 },
      { x: 0.2, y: 0.6, r: 0.25, rgb: [40, 60, 100], alpha: 0.06 },
      { x: 0.8, y: 0.7, r: 0.28, rgb: [50, 30, 70], alpha: 0.07 },
    ];

    const intensity = CONFIG.nebulaIntensity;
    for (const neb of nebulaColors) {
      const grad = bgCtx.createRadialGradient(
        W * neb.x, H * neb.y, 0,
        W * neb.x, H * neb.y, Math.max(W, H) * neb.r
      );
      const [r, g, b] = neb.rgb;
      const a = neb.alpha * intensity;
      grad.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${a})`);
      grad.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${a * 0.5})`);
      grad.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
      bgCtx.fillStyle = grad;
      bgCtx.fillRect(0, 0, W, H);
    }

    // Cosmic dust - subtle noise-like particles
    bgCtx.save();
    const dustCount = Math.floor((W * H) / 14000);
    for (let i = 0; i < dustCount; i++) {
      const x = Math.random() * W;
      const y = Math.random() * H;
      const size = Math.random() * 1.2 * DPR;
      const alpha = Math.random() * 0.15 + 0.02;
      bgCtx.fillStyle = `rgba(180, 200, 255, ${alpha})`;
      bgCtx.beginPath();
      bgCtx.arc(x, y, size, 0, Math.PI * 2);
      bgCtx.fill();
    }
    bgCtx.restore();

    // Subtle vignette
    const vignette = bgCtx.createRadialGradient(W * 0.5, H * 0.5, W * 0.2, W * 0.5, H * 0.5, Math.max(W, H) * 0.7);
    vignette.addColorStop(0, 'rgba(0,0,0,0)');
    vignette.addColorStop(0.7, 'rgba(0,0,0,0.2)');
    vignette.addColorStop(1, 'rgba(0,0,0,0.5)');
    bgCtx.fillStyle = vignette;
    bgCtx.fillRect(0, 0, W, H);
  }

  function applyPosterVignette() {
    const pr = posterRect();
    const x = pr.x * DPR;
    const y = pr.y * DPR;
    const w = pr.w * DPR;
    const h = pr.h * DPR;

    bgCtx.save();
    bgCtx.globalCompositeOperation = "multiply";
    const vignette = bgCtx.createRadialGradient(
      x + w * 0.5, y + h * 0.6, w * 0.2,
      x + w * 0.5, y + h * 0.6, w * 0.9
    );
    vignette.addColorStop(0, "rgba(0,0,0,0)");
    vignette.addColorStop(1, "rgba(0,0,0,0.35)");
    bgCtx.fillStyle = vignette;
    bgCtx.fillRect(x, y, w, h);
    bgCtx.restore();
  }

  // ========= Get poster dimensions =========
  function posterRect(){
    const frame = document.querySelector(".frame");
    const r = frame.getBoundingClientRect();
    return { x: r.left, y: r.top, w: r.width, h: r.height };
  }

  // ========= Convert stars to screen positions =========
  function getStarScreenPositions() {
    const pr = posterRect();
    const cx = (pr.x + pr.w / 2) * DPR;
    const cy = (pr.y + pr.h / 2) * DPR;
    const R = Math.min(pr.w, pr.h) * 0.42 * DPR;

    const visibleStars = [];

    for (let i = 0; i < STARS.length; i++) {
      const [name, ra, dec, mag, colorIndex] = STARS[i];
      const pos = raDecToAltAz(ra, dec, CONFIG.lat, lst);

      // Only show stars above the horizon
      if (pos.altitude > 0) {
        // Stereographic projection for the sky dome
        const r = R * (90 - pos.altitude) / 90;
        const angle = (pos.azimuth - 180) * Math.PI / 180; // Rotate so north is up

        const x = cx + r * Math.sin(angle);
        const y = cy - r * Math.cos(angle); // Invert Y for screen coords

        // Size based on magnitude (brighter = larger)
        const size = Math.max(0.6, (3.2 - mag) * 0.55) * DPR;

        // Color based on color index (B-V)
        let color;
        if (colorIndex < 0) {
          color = { r: 180, g: 200, b: 255 }; // Blue-white
        } else if (colorIndex < 0.3) {
          color = { r: 220, g: 230, b: 255 }; // White
        } else if (colorIndex < 0.6) {
          color = { r: 255, g: 250, b: 240 }; // Yellow-white
        } else if (colorIndex < 1.0) {
          color = { r: 255, g: 230, b: 180 }; // Yellow
        } else if (colorIndex < 1.5) {
          color = { r: 255, g: 200, b: 150 }; // Orange
        } else {
          color = { r: 255, g: 160, b: 120 }; // Red
        }

        const colorStr = `rgb(${color.r}, ${color.g}, ${color.b})`;
        const alpha = Math.min(1, 0.35 + (3.2 - mag) * 0.12);
        const twinklePhase = Math.random() * Math.PI * 2;
        const twinkleSpeed = 0.6 + Math.random() * 0.9;
        visibleStars.push({
          index: i,
          name,
          x, y,
          size,
          mag,
          colorStr,
          alpha,
          twinklePhase,
          twinkleSpeed,
          altitude: pos.altitude,
          azimuth: pos.azimuth,
        });
      }
    }

    const starByIndex = new Map();
    for (const star of visibleStars) starByIndex.set(star.index, star);
    const linePairs = [];
    for (const [i, j] of CONSTELLATION_LINES) {
      const a = starByIndex.get(i);
      const b = starByIndex.get(j);
      if (a && b) linePairs.push([a, b]);
    }

    // Extra faint stars for density
    const faintStars = [];
    const extraCount = Math.floor((R * R) / (DPR * 40));
    for (let i = 0; i < extraCount; i++) {
      const t = Math.random() * Math.PI * 2;
      const u = Math.random();
      const rr = Math.sqrt(u) * R;
      const fx = cx + Math.cos(t) * rr;
      const fy = cy + Math.sin(t) * rr;
      const size = (Math.random() * 0.7 + 0.3) * DPR;
      const alpha = 0.15 + Math.random() * 0.35;
      faintStars.push({ x: fx, y: fy, size, alpha });
    }

    // Extra line connections between nearby brighter stars
    const extraLines = [];
    const bright = visibleStars.filter(s => s.mag < 2.6);
    for (const star of bright) {
      const neighbors = [];
      for (const other of bright) {
        if (other === star) continue;
        const dx = other.x - star.x;
        const dy = other.y - star.y;
        const d2 = dx * dx + dy * dy;
        if (d2 < (R * 0.35) * (R * 0.35)) {
          neighbors.push({ other, d2 });
        }
      }
      neighbors.sort((a, b) => a.d2 - b.d2);
      for (let i = 0; i < Math.min(3, neighbors.length); i++) {
        extraLines.push([star, neighbors[i].other]);
      }
    }

    return { stars: visibleStars, cx, cy, R, linePairs, faintStars, extraLines };
  }

  let starData = getStarScreenPositions();

  // Rebuild on resize
  let resizeTimer = null;
  window.addEventListener("resize", () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      rebuildSky();
    }, 120);
  }, { passive: true });

  // ========= Static + animated render =========
  function drawStaticLayer() {
    staticCtx.clearRect(0, 0, W, H);

    const { cx, cy, R, linePairs, faintStars, extraLines } = starData;

    // Map halo behind circle
    const halo = staticCtx.createRadialGradient(cx, cy, R * 0.1, cx, cy, R * 1.1);
    halo.addColorStop(0, "rgba(120, 160, 220, 0.08)");
    halo.addColorStop(0.6, "rgba(120, 160, 220, 0.04)");
    halo.addColorStop(1, "rgba(120, 160, 220, 0)");
    staticCtx.fillStyle = halo;
    staticCtx.beginPath();
    staticCtx.arc(cx, cy, R * 1.08, 0, Math.PI * 2);
    staticCtx.fill();

    // Soft map shadow
    staticCtx.save();
    staticCtx.globalCompositeOperation = "multiply";
    staticCtx.fillStyle = "rgba(0,0,0,0.25)";
    staticCtx.beginPath();
    staticCtx.ellipse(cx + 6 * DPR, cy + 10 * DPR, R * 0.95, R * 0.95, 0, 0, Math.PI * 2);
    staticCtx.fill();
    staticCtx.restore();

    // Milky Way band
    staticCtx.save();
    staticCtx.globalCompositeOperation = "screen";
    staticCtx.translate(cx, cy);
    staticCtx.rotate(-18 * Math.PI / 180);
    const band = staticCtx.createRadialGradient(0, 0, R * 0.05, 0, 0, R * 0.9);
    band.addColorStop(0, "rgba(160, 190, 255, 0.22)");
    band.addColorStop(0.4, "rgba(140, 175, 255, 0.12)");
    band.addColorStop(1, "rgba(130, 170, 255, 0)");
    staticCtx.fillStyle = band;
    staticCtx.beginPath();
    staticCtx.ellipse(0, 0, R * 0.95, R * 0.25, 0, 0, Math.PI * 2);
    staticCtx.fill();
    staticCtx.restore();

    // Constellation lines (simple solid color, no gradients)
    if (CONFIG.showConstellationLines) {
      staticCtx.strokeStyle = 'rgba(100, 140, 200, 0.1)';
      staticCtx.lineWidth = 1 * DPR;
      for (const [starA, starB] of linePairs) {
        staticCtx.beginPath();
        staticCtx.moveTo(starA.x, starA.y);
        staticCtx.lineTo(starB.x, starB.y);
        staticCtx.stroke();
      }
    }

    // Extra subtle lines between nearby stars
    staticCtx.strokeStyle = "rgba(190, 210, 255, 0.08)";
    staticCtx.lineWidth = 1 * DPR;
    for (const [starA, starB] of extraLines) {
      staticCtx.beginPath();
      staticCtx.moveTo(starA.x, starA.y);
      staticCtx.lineTo(starB.x, starB.y);
      staticCtx.stroke();
    }

    // Circular boundary
    staticCtx.strokeStyle = "rgba(233, 238, 252, 0.15)";
    staticCtx.lineWidth = 1 * DPR;
    staticCtx.beginPath();
    staticCtx.arc(cx, cy, R, 0, Math.PI * 2);
    staticCtx.stroke();

    // Inner circle
    staticCtx.strokeStyle = "rgba(233, 238, 252, 0.06)";
    staticCtx.beginPath();
    staticCtx.arc(cx, cy, R * 0.5, 0, Math.PI * 2);
    staticCtx.stroke();

    // Subtle coordinate grid
    staticCtx.strokeStyle = "rgba(233, 238, 252, 0.04)";
    staticCtx.lineWidth = 1 * DPR;
    for (let r = 0.2; r <= 0.9; r += 0.2) {
      staticCtx.beginPath();
      staticCtx.arc(cx, cy, R * r, 0, Math.PI * 2);
      staticCtx.stroke();
    }
    for (let a = 0; a < 360; a += 30) {
      const rad = (a - 90) * Math.PI / 180;
      staticCtx.beginPath();
      staticCtx.moveTo(cx, cy);
      staticCtx.lineTo(cx + Math.cos(rad) * R, cy + Math.sin(rad) * R);
      staticCtx.stroke();
    }

    // Faint background stars
    staticCtx.fillStyle = "rgba(220, 230, 255, 1)";
    for (const s of faintStars) {
      staticCtx.globalAlpha = s.alpha;
      staticCtx.beginPath();
      staticCtx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
      staticCtx.fill();
    }
    staticCtx.globalAlpha = 1;

    // Compass ticks
    staticCtx.strokeStyle = "rgba(233, 238, 252, 0.18)";
    staticCtx.lineWidth = 1 * DPR;
    for (let a = 0; a < 360; a += 15) {
      const rad = (a - 90) * Math.PI / 180;
      const len = (a % 45 === 0) ? 8 * DPR : 4 * DPR;
      const x0 = cx + Math.cos(rad) * (R - len);
      const y0 = cy + Math.sin(rad) * (R - len);
      const x1 = cx + Math.cos(rad) * (R + 1 * DPR);
      const y1 = cy + Math.sin(rad) * (R + 1 * DPR);
      staticCtx.beginPath();
      staticCtx.moveTo(x0, y0);
      staticCtx.lineTo(x1, y1);
      staticCtx.stroke();
    }

    // North marker
    staticCtx.fillStyle = "rgba(233, 238, 252, 0.6)";
    staticCtx.font = `${10 * DPR}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
    staticCtx.textAlign = "center";
    staticCtx.textBaseline = "middle";
    staticCtx.fillText("N", cx, cy - R - 12 * DPR);

    // Constellation labels (subtle)
    staticCtx.fillStyle = "rgba(233, 238, 252, 0.35)";
    staticCtx.font = `${9 * DPR}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
    staticCtx.textAlign = "left";
    staticCtx.textBaseline = "middle";
    const labels = [
      { name: "Orion", idx: 7 },
      { name: "Cygnus", idx: 14 },
      { name: "Leo", idx: 15 },
      { name: "Gemini", idx: 6 },
      { name: "Cassiopeia", idx: 38 },
      { name: "Scorpius", idx: 10 },
    ];
    for (const label of labels) {
      const star = starData.stars.find(s => s.index === label.idx);
      if (!star) continue;
      staticCtx.fillText(label.name, star.x + 8 * DPR, star.y - 6 * DPR);
    }
  }

  const glowCache = new Map();
  function getGlowSprite(size, colorStr, isBright) {
    const key = `${Math.round(size * 2) / 2}|${colorStr}|${isBright ? 1 : 0}`;
    const cached = glowCache.get(key);
    if (cached) return cached;

    const radius = size * (isBright ? 3.4 : 2.2);
    const dim = Math.ceil(radius * 2 + 2);
    const c = document.createElement("canvas");
    c.width = dim;
    c.height = dim;
    const g = c.getContext("2d");
    const grad = g.createRadialGradient(dim / 2, dim / 2, 0, dim / 2, dim / 2, radius);
    grad.addColorStop(0, colorStr.replace("rgb", "rgba").replace(")", ",0.9)"));
    grad.addColorStop(0.6, colorStr.replace("rgb", "rgba").replace(")", ",0.25)"));
    grad.addColorStop(1, colorStr.replace("rgb", "rgba").replace(")", ",0)"));
    g.fillStyle = grad;
    g.beginPath();
    g.arc(dim / 2, dim / 2, radius, 0, Math.PI * 2);
    g.fill();

    glowCache.set(key, c);
    return c;
  }

  function drawFrame(now) {
    ctx.clearRect(0, 0, W, H);
    const driftX = Math.sin(now / 6000) * 0.6 * DPR;
    const driftY = Math.cos(now / 7000) * 0.6 * DPR;
    ctx.drawImage(staticCanvas, driftX, driftY);

    const { stars } = starData;
    for (const star of stars) {
      const pulse = 0.55 + 0.45 * Math.sin(now / 1000 * star.twinkleSpeed + star.twinklePhase);
      const alpha = star.alpha * pulse;
      const size = star.size;
      const isBright = star.mag < 1.2;

      // Realistic glow (sprite cached)
      const glow = getGlowSprite(size, star.colorStr, isBright);
      ctx.globalAlpha = alpha * (isBright ? 1.0 : 0.65);
      ctx.drawImage(glow, star.x + driftX - glow.width / 2, star.y + driftY - glow.height / 2);

      // Star core
      ctx.globalAlpha = alpha * (isBright ? 1.0 : 0.95);
      ctx.beginPath();
      ctx.arc(star.x + driftX, star.y + driftY, size, 0, Math.PI * 2);
      ctx.fill();

      // Bright white center
      if (isBright) {
        ctx.globalAlpha = alpha * 0.9;
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(star.x + driftX, star.y + driftY, size * 0.45, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    ctx.globalAlpha = 1;

    // Shooting stars
    maybeSpawnShootingStar(now);
    if (shooting) {
      shooting.life++;
      const progress = shooting.life / shooting.maxLife;
      const x1 = shooting.x;
      const y1 = shooting.y;
      shooting.x += shooting.vx;
      shooting.y += shooting.vy;

      const alpha = Math.max(0, 1 - progress);
      ctx.globalAlpha = alpha;
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(x1, y1, 2.4 * DPR, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = alpha * 0.8;
      ctx.strokeStyle = "rgba(200,230,255,0.8)";
      ctx.lineWidth = 1.4 * DPR;
      ctx.lineCap = "round";
      const trailLen = 10 + progress * 10;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x1 - shooting.vx * trailLen, y1 - shooting.vy * trailLen);
      ctx.stroke();

      ctx.globalAlpha = 1;

      if (shooting.life >= shooting.maxLife) shooting = null;
    }
  }

  // ========= Shooting stars =========
  let shooting = null;
  let nextShootAt = 0;
  function maybeSpawnShootingStar(now) {
    if (shooting) return;
    if (now < nextShootAt) return;
    nextShootAt = now + 7000 + Math.random() * 9000;

    const { cx, cy, R } = starData;
    const ang = Math.random() * Math.PI * 2;
    const startR = R * (0.6 + Math.random() * 0.35);
    const x0 = cx + startR * Math.cos(ang);
    const y0 = cy + startR * Math.sin(ang);

    const dir = ang + Math.PI * (0.35 + Math.random() * 0.3) * (Math.random() < 0.5 ? 1 : -1);
    shooting = {
      x: x0,
      y: y0,
      vx: Math.cos(dir) * (8 + Math.random() * 6) * DPR,
      vy: Math.sin(dir) * (8 + Math.random() * 6) * DPR,
      life: 0,
      maxLife: 18 + Math.floor(Math.random() * 16),
    };
  }

  function rebuildSky() {
    starData = getStarScreenPositions();
    drawStaticLayer();
    drawFrame(0);
  }

  let running = true;
  let lastFrame = 0;
  let targetFrameMs = 1000 / 24;
  function animate(now) {
    if (!running) return;
    const delta = now - lastFrame;
    if (delta >= targetFrameMs) {
      lastFrame = now;
      // Update parallax in the same loop
      parallaxX += (targetX - parallaxX) * 0.08;
      parallaxY += (targetY - parallaxY) * 0.08;
      bgCanvas.style.transform = `translate(${parallaxX}px, ${parallaxY}px)`;

      drawFrame(now);

      // Adaptive FPS
      if (delta > 50) {
        targetFrameMs = 1000 / 20;
      } else if (delta < 35) {
        targetFrameMs = 1000 / 24;
      }
    }
    requestAnimationFrame(animate);
  }

  const infoEl = document.getElementById("starInfo");
  function setStarInfo(star) {
    if (!infoEl) return;
    if (!star) {
      infoEl.innerHTML = '<span class="name">Hover a bright star</span><span class="value">Name, magnitude, altitude, azimuth</span>';
      return;
    }
    const alt = `${star.altitude.toFixed(1)}°`;
    const az = `${star.azimuth.toFixed(1)}°`;
    infoEl.innerHTML =
      `<span class="name">${star.name}</span>` +
      `<span class="value">Magnitude: ${star.mag.toFixed(2)}</span>` +
      `<span class="value">Altitude: ${alt}</span>` +
      `<span class="value">Azimuth: ${az}</span>`;
  }

  function findNearestStar(x, y) {
    const { stars, cx, cy, R } = starData;
    const dx = x - cx;
    const dy = y - cy;
    if ((dx * dx + dy * dy) > (R * R)) return null;
    let best = null;
    let bestDist = Infinity;
    for (const star of stars) {
      if (star.mag > 2.2) continue;
      const sx = star.x - x;
      const sy = star.y - y;
      const d2 = sx * sx + sy * sy;
      const hit = (star.size * 3 + 6 * DPR);
      if (d2 < hit * hit && d2 < bestDist) {
        bestDist = d2;
        best = star;
      }
    }
    return best;
  }

  canvas.addEventListener("pointermove", (e) => {
    const x = e.clientX * DPR;
    const y = e.clientY * DPR;
    const star = findNearestStar(x, y);
    setStarInfo(star);
  }, { passive: true });

  canvas.addEventListener("pointerleave", () => {
    setStarInfo(null);
  }, { passive: true });

  rebuildSky();
  requestAnimationFrame(animate);

  document.addEventListener("visibilitychange", () => {
    running = !document.hidden;
    if (running) requestAnimationFrame(animate);
  });
})();
</script>
</body>
</html>
